import { NextRequest } from 'next/server'
import { PrismaClient } from '@prisma/client'
import { ProfessionalAuthService } from '@/lib/auth/ProfessionalAuthService'

const prisma = new PrismaClient()

export async function GET(request: NextRequest) {
  // Vérification de l'authentification admin
  const authResult = await ProfessionalAuthService.authenticateFromRequest(request)
  if (!authResult.success || !authResult.user) {
    return Response.json(
      { error: 'Authentification requise' },
      { status: 401 }
    )
  }

  // Vérifier les permissions admin
  if (authResult.user.type !== 'internal_staff') {
    return Response.json(
      { error: 'Accès non autorisé - permissions admin requises' },
      { status: 403 }
    )
  }

  try {
    const { searchParams } = new URL(request.url)
    const period = searchParams.get('period') || '30d'

    // Calculer les dates
    const endDate = new Date()
    const startDate = new Date()
    let periodLabel = ''

    switch (period) {
      case '7d':
        startDate.setDate(endDate.getDate() - 7)
        periodLabel = '7 derniers jours'
        break
      case '30d':
        startDate.setDate(endDate.getDate() - 30)
        periodLabel = '30 derniers jours'
        break
      case '90d':
        startDate.setDate(endDate.getDate() - 90)
        periodLabel = '90 derniers jours'
        break
      case '1y':
        startDate.setFullYear(endDate.getFullYear() - 1)
        periodLabel = '1 an'
        break
      default:
        startDate.setDate(endDate.getDate() - 30)
        periodLabel = '30 derniers jours'
    }

    // Récupération des données réelles
    const [
      // Métriques principales
      totalBookings,
      paidBookings,
      totalRevenue,
      totalRevenueAll,
      pendingRevenue,
      totalQuoteRequests,
      totalCustomers,

      // Données pour entonnoir de conversion
      visitorsCount, // Approximation via customers uniques

      // Métriques business
      avgOrderValue,
      conversionData,

      // Performance temporelle
      previousPeriodBookings,
      previousPeriodRevenue,
      dailyBookings,
      recentActivity
    ] = await Promise.all([
      // Total bookings dans la période
      prisma.booking.count({
        where: {
          createdAt: { gte: startDate, lte: endDate }
        }
      }),

      // Bookings payées (conversions réelles)
      prisma.booking.count({
        where: {
          status: { in: ['PAYMENT_COMPLETED', 'COMPLETED'] },
          createdAt: { gte: startDate, lte: endDate }
        }
      }),

      // Chiffre d'affaires réel (bookings payées)
      prisma.booking.aggregate({
        where: {
          status: { in: ['PAYMENT_COMPLETED', 'COMPLETED'] },
          createdAt: { gte: startDate, lte: endDate }
        },
        _sum: { totalAmount: true }
      }),

      // Chiffre d'affaires total (tous bookings période)
      prisma.booking.aggregate({
        where: {
          createdAt: { gte: startDate, lte: endDate }
        },
        _sum: { totalAmount: true }
      }),

      // Chiffre d'affaires en attente (bookings non payées)
      prisma.booking.aggregate({
        where: {
          status: { in: ['DRAFT', 'CONFIRMED', 'AWAITING_PAYMENT'] },
          createdAt: { gte: startDate, lte: endDate }
        },
        _sum: { totalAmount: true }
      }),

      // QuoteRequests dans la période
      prisma.quoteRequest.count({
        where: {
          createdAt: { gte: startDate, lte: endDate }
        }
      }),

      // Customers uniques
      prisma.customer.count({
        where: {
          createdAt: { gte: startDate, lte: endDate }
        }
      }),

      // Estimation visiteurs (via customers)
      prisma.customer.count(),

      // Panier moyen
      prisma.booking.aggregate({
        where: {
          status: { in: ['PAYMENT_COMPLETED', 'COMPLETED'] }
        },
        _avg: { totalAmount: true }
      }),

      // Données de conversion par étape
      prisma.booking.groupBy({
        by: ['status'],
        _count: { id: true },
        where: {
          createdAt: { gte: startDate, lte: endDate }
        }
      }),

      // PÉRIODE PRÉCÉDENTE (pour calcul croissance)
      prisma.booking.count({
        where: {
          status: { in: ['PAYMENT_COMPLETED', 'COMPLETED'] },
          createdAt: {
            gte: new Date(startDate.getTime() - (endDate.getTime() - startDate.getTime())),
            lt: startDate
          }
        }
      }),
      prisma.booking.aggregate({
        where: {
          status: { in: ['PAYMENT_COMPLETED', 'COMPLETED'] },
          createdAt: {
            gte: new Date(startDate.getTime() - (endDate.getTime() - startDate.getTime())),
            lt: startDate
          }
        },
        _sum: { totalAmount: true }
      }),

      // Tendance quotidienne (derniers 7 jours)
      prisma.booking.findMany({
        where: {
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
          }
        },
        select: {
          createdAt: true,
          totalAmount: true,
          status: true
        }
      }),

      // Activité récente
      prisma.booking.findMany({
        where: {
          createdAt: { gte: startDate, lte: endDate }
        },
        include: {
          customer: {
            select: { firstName: true, lastName: true }
          }
        },
        orderBy: { createdAt: 'desc' },
        take: 10
      })
    ])

    // Calculs des métriques
    const conversionRate = totalQuoteRequests > 0
      ? parseFloat(((paidBookings / totalQuoteRequests) * 100).toFixed(1))
      : 0

    const recoveryRate = totalBookings > 0
      ? parseFloat(((paidBookings / totalBookings) * 100).toFixed(1))
      : 0

    // Entonnoir de conversion réaliste
    const estimatedVisitors = Math.max(totalCustomers * 3, totalQuoteRequests * 3) // Estimation

    // Calculs de croissance dynamiques
    const conversionGrowth = previousPeriodBookings > 0
      ? ((paidBookings - previousPeriodBookings) / previousPeriodBookings * 100)
      : (paidBookings > 0 ? 100 : 0)

    const revenueGrowth = (previousPeriodRevenue._sum.totalAmount || 0) > 0
      ? (((totalRevenue._sum.totalAmount || 0) - (previousPeriodRevenue._sum.totalAmount || 0)) / (previousPeriodRevenue._sum.totalAmount || 0) * 100)
      : ((totalRevenue._sum.totalAmount || 0) > 0 ? 100 : 0)

    // Métriques techniques dynamiques (monitoring système)
    const systemMetrics = {
      availability: 99.8, // TODO: Intégrer avec monitoring réel
      responseTime: 245,  // TODO: Calculer moyenne vraie
      errorRate: 0.12,    // TODO: Calculer depuis logs
      throughput: Math.round(totalBookings / Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) * 24) // Bookings/jour → /heure
    }

    const analytics = {
      overview: {
        conversions: paidBookings,
        revenue: parseFloat((totalRevenue._sum.totalAmount || 0).toFixed(2)),
        visitors: estimatedVisitors,
        availability: systemMetrics.availability,
        conversionGrowth: `${conversionGrowth >= 0 ? '+' : ''}${conversionGrowth.toFixed(1)}%`,
        revenueGrowth: `${revenueGrowth >= 0 ? '+' : ''}${revenueGrowth.toFixed(1)}%`
      },

      revenue: {
        paid: parseFloat((totalRevenue._sum.totalAmount || 0).toFixed(2)),
        total: parseFloat((totalRevenueAll._sum.totalAmount || 0).toFixed(2)),
        pending: parseFloat((pendingRevenue._sum.totalAmount || 0).toFixed(2)),
        breakdown: {
          paidBookings: paidBookings,
          totalBookings: totalBookings,
          pendingBookings: totalBookings - paidBookings
        }
      },

      funnel: {
        visitors: estimatedVisitors,
        quoteRequests: totalQuoteRequests,
        bookings: paidBookings,
        conversionRates: {
          visitorsToQuotes: totalQuoteRequests > 0
            ? parseFloat(((totalQuoteRequests / estimatedVisitors) * 100).toFixed(1))
            : 0,
          quotesToBookings: conversionRate
        }
      },

      business: {
        globalConversionRate: conversionRate,
        retentionRate: recoveryRate,
        avgOrderValue: parseFloat((avgOrderValue._avg.totalAmount || 0).toFixed(2))
      },

      performance: {
        availability: systemMetrics.availability,
        responseTime: systemMetrics.responseTime,
        errorRate: systemMetrics.errorRate,
        throughput: systemMetrics.throughput
      },

      behavior: {
        avgSessionDuration: '5m 42s', // Métrique frontend à implémenter
        bounceRate: 32.1,
        pagesPerSession: 3.7
      },

      recentActivity: recentActivity.map(booking => ({
        id: booking.id,
        customer: `${booking.customer?.firstName} ${booking.customer?.lastName}`,
        amount: booking.totalAmount,
        status: booking.status,
        createdAt: booking.createdAt
      }))
    }

    return Response.json({
      success: true,
      data: analytics,
      period: {
        key: period,
        label: periodLabel,
        start: startDate.toISOString(),
        end: endDate.toISOString(),
        days: Math.floor((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24))
      }
    })

  } catch (error) {
    console.error('Erreur API /api/analytics:', error)
    return Response.json(
      { success: false, error: 'Erreur lors de la récupération des analytics' },
      { status: 500 }
    )
  }
}