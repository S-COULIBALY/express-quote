import { Money } from './Money';
import { QuoteContext } from './QuoteContext';

/**
 * R√©sultat de l'application d'une r√®gle
 */
export interface RuleApplyResult {
  success: boolean;
  modified: boolean;
  price: number;
  message?: string;
  isApplied: boolean;
  impact: number;
  newPrice: Money;
  minimumPrice?: number;
}

/**
 * Classe repr√©sentant une r√®gle de tarification
 * Une r√®gle peut √™tre un discount (r√©duction) ou une surcharge (majoration)
 */
export class Rule {
  // Fonction optionnelle qui peut √™tre utilis√©e √† la place de la condition en cha√Æne
  private applyFunction?: ((context: any) => RuleApplyResult);
  
  constructor(
    public readonly name: string,
    public readonly serviceType: string,
    public readonly value: number,
    public readonly condition: string = '',
    public readonly isActive: boolean = true,
    public readonly id?: string,
    public readonly percentBased?: boolean
  ) {}

  /**
   * D√©termine si une r√®gle est applicable en fonction du contexte
   * @param context Contexte contenant les donn√©es pour √©valuer la condition
   */
  isApplicable(context: any): boolean {
    // Si on a une fonction d'application personnalis√©e, l'utiliser
    if (typeof this.applyFunction === 'function') {
      const result = this.applyFunction(context);
      return result.success && result.modified;
    }

    // Si aucune condition n'est sp√©cifi√©e, la r√®gle est toujours applicable
    if (!this.condition || this.condition.trim() === '') {
      return true;
    }

    try {
      // Extraire la date programm√©e du contexte
      let scheduledDate: Date | null = null;
      
      if (context.scheduledDate) {
        scheduledDate = new Date(context.scheduledDate);
      } else if (context.date) {
        scheduledDate = new Date(context.date);
      } else if (context.booking?.date) {
        scheduledDate = new Date(context.booking.date);
      }
      
      // Extraire le prix par d√©faut du contexte
      let defaultPrice = 0;
      if (context.defaultPrice) {
        defaultPrice = typeof context.defaultPrice === 'object' && context.defaultPrice.getAmount 
          ? context.defaultPrice.getAmount() 
          : parseFloat(context.defaultPrice);
      }
      
      const now = new Date();
      
      // üèóÔ∏è D√âTECTION ET GESTION DU MONTE-MEUBLE OBLIGATOIRE
      const furnitureLiftAnalysis = this.analyzeFurnitureLiftRequirement(context);
      
      // Cr√©er un contexte enrichi pour l'√©valuation
      const evalContext = {
        ...context,
        // Ajouter la valeur de la r√®gle au contexte
        value: this.value,
        // Variables temporelles
        date: scheduledDate,
        now: now,
        day: scheduledDate ? scheduledDate.getDay() : now.getDay(),
        hour: scheduledDate ? scheduledDate.getHours() : now.getHours(),
        diffDays: scheduledDate ? Math.floor((scheduledDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)) : 0,
        diffHours: scheduledDate ? Math.floor((scheduledDate.getTime() - now.getTime()) / (1000 * 60 * 60)) : 0,
        // Prix
        price: context.price || defaultPrice || 0,
        duration: context.duration || 1,
        // Informations client
        isReturningCustomer: context.isReturningCustomer || false,
        
        // üèóÔ∏è GESTION DU MONTE-MEUBLE ET CONTRAINTES CONSOMM√âES
        monte_meuble_requis: furnitureLiftAnalysis.required,
        consumedConstraints: furnitureLiftAnalysis.consumedConstraints,
        
        // ‚úÖ VARIABLES DE BASE POUR LES CALCULS
        volume: parseFloat(context.volume || '0'),
        distance: parseFloat(context.distance || '0'),
        workers: parseInt(context.workers || context.numberOfMovers || '2'),
        numberOfMovers: parseInt(context.numberOfMovers || context.workers || '2'),
        numberOfBoxes: parseInt(context.numberOfBoxes || '0'),
        
        // Variables d'√©tage
        pickupFloor: parseInt(context.pickupFloor || '0'),
        deliveryFloor: parseInt(context.deliveryFloor || '0'),
        pickupElevator: context.pickupElevator === 'yes' || context.pickupElevator === 'medium' || context.pickupElevator === 'large',
        deliveryElevator: context.deliveryElevator === 'yes' || context.deliveryElevator === 'medium' || context.deliveryElevator === 'large',
        hasElevator: (context.pickupElevator === 'yes' || context.pickupElevator === 'medium' || context.pickupElevator === 'large') && 
                    (context.deliveryElevator === 'yes' || context.deliveryElevator === 'medium' || context.deliveryElevator === 'large'),
        
        // ‚ú® NOUVELLES VARIABLES: Distance de portage
        pickupCarryDistance: context.pickupCarryDistance || '',
        deliveryCarryDistance: context.deliveryCarryDistance || '',
        
        // Variables temporelles suppl√©mentaires
        month: scheduledDate ? scheduledDate.getMonth() : now.getMonth(),
        
        // ‚úÖ Variables bool√©ennes pour toutes les contraintes et services
        // Contraintes logistiques d'acc√®s
        furniture_lift_required: this.hasLogisticsConstraint(context, 'furniture_lift_required'),
        pedestrian_zone: this.hasLogisticsConstraint(context, 'pedestrian_zone'),
        narrow_inaccessible_street: this.hasLogisticsConstraint(context, 'narrow_inaccessible_street'),
        difficult_parking: this.hasLogisticsConstraint(context, 'difficult_parking'),
        complex_traffic: this.hasLogisticsConstraint(context, 'complex_traffic'),
        elevator_unavailable: this.hasLogisticsConstraint(context, 'elevator_unavailable'),
        elevator_unsuitable_size: this.hasLogisticsConstraint(context, 'elevator_unsuitable_size'),
        elevator_forbidden_moving: this.hasLogisticsConstraint(context, 'elevator_forbidden_moving'),
        difficult_stairs: this.hasLogisticsConstraint(context, 'difficult_stairs'),
        narrow_corridors: this.hasLogisticsConstraint(context, 'narrow_corridors'),
        long_carrying_distance: this.hasLogisticsConstraint(context, 'long_carrying_distance'),
        indirect_exit: this.hasLogisticsConstraint(context, 'indirect_exit'),
        complex_multilevel_access: this.hasLogisticsConstraint(context, 'complex_multilevel_access'),
        access_control: this.hasLogisticsConstraint(context, 'access_control'),
        administrative_permit: this.hasLogisticsConstraint(context, 'administrative_permit'),
        time_restrictions: this.hasLogisticsConstraint(context, 'time_restrictions'),
        fragile_floor: this.hasLogisticsConstraint(context, 'fragile_floor'),
        
        // Services suppl√©mentaires
        bulky_furniture: this.hasLogisticsConstraint(context, 'bulky_furniture'),
        furniture_disassembly: this.hasLogisticsConstraint(context, 'furniture_disassembly'),
        furniture_reassembly: this.hasLogisticsConstraint(context, 'furniture_reassembly'),
        professional_packing_departure: this.hasLogisticsConstraint(context, 'professional_packing_departure'),
        professional_unpacking_arrival: this.hasLogisticsConstraint(context, 'professional_unpacking_arrival'),
        packing_supplies: this.hasLogisticsConstraint(context, 'packing_supplies'),
        fragile_valuable_items: this.hasLogisticsConstraint(context, 'fragile_valuable_items'),
        heavy_items: this.hasLogisticsConstraint(context, 'heavy_items'),
        additional_insurance: this.hasLogisticsConstraint(context, 'additional_insurance'),
        temporary_storage_service: this.hasLogisticsConstraint(context, 'temporary_storage_service'),

        // ‚úÖ VARIABLES MANQUANTES POUR LES R√àGLES MOVING
        // Variables utilis√©es dans MovingRules.ts qui √©taient manquantes
        hasFragileItems: this.hasLogisticsConstraint(context, 'fragile_valuable_items') || context.hasFragileItems || false,
        needsLift: this.hasLogisticsConstraint(context, 'furniture_lift_required') || context.needsLift || false,
        pickupNarrowStairs: context.pickupNarrowStairs || false,
        deliveryNarrowStairs: context.deliveryNarrowStairs || false
      };
      
      // üö´ FILTRAGE DES CONTRAINTES CONSOMM√âES PAR LE MONTE-MEUBLE
      if (this.isConstraintConsumedByFurnitureLift(evalContext)) {
        console.log(`üö´ R√®gle "${this.name}" ignor√©e - contrainte consomm√©e par le monte-meuble`);
        return false;
      }

      // ‚úÖ CORRECTION: G√©rer les conditions JSON ET les expressions JavaScript
      let result: boolean;

      // D√©tecter si c'est un objet JSON ou une expression JS
      const conditionStr = this.condition.trim();
      if (conditionStr.startsWith('{') || conditionStr.startsWith('[')) {
        // C'est un objet JSON - parser et √©valuer intelligemment
        try {
          const conditionObj = JSON.parse(conditionStr);
          result = this.evaluateJsonCondition(conditionObj, evalContext);
        } catch (parseError) {
          console.error(`‚ùå Erreur parsing JSON condition pour "${this.name}":`, parseError);
          return false;
        }
      } else {
        // C'est une expression JavaScript - √©valuer avec Function
        try {
          const evalFunction = new Function(...Object.keys(evalContext), `return (${this.condition});`);
          result = evalFunction(...Object.values(evalContext));
        } catch (evalError) {
          console.error(`‚ùå Erreur √©valuation JS condition pour "${this.name}":`, evalError);
          return false;
        }
      }

      // üîç LOGS DE D√âBOGAGE POUR LA R√àGLE MONTE-MEUBLE
      if (this.name === 'Suppl√©ment monte-meuble') {
        console.log('üîç [RULE-DEBUG] === R√àGLE MONTE-MEUBLE ===');
        console.log(`üîç [RULE-DEBUG] Condition: ${this.condition}`);
        console.log(`üîç [RULE-DEBUG] R√©sultat: ${result}`);
        console.log(`üîç [RULE-DEBUG] furniture_lift_required: ${evalContext.furniture_lift_required}`);
        console.log(`üîç [RULE-DEBUG] pickupLogisticsConstraints: ${JSON.stringify(evalContext.pickupLogisticsConstraints)}`);
        console.log(`üîç [RULE-DEBUG] deliveryLogisticsConstraints: ${JSON.stringify(evalContext.deliveryLogisticsConstraints)}`);
      }

      return result;
    } catch (error) {
      console.error(`Error evaluating rule condition: ${this.condition}`, error);
      return false;
    }
  }

  /**
   * Applique la r√®gle au prix en fonction de sa valeur
   * @param price Prix actuel
   * @param context Contexte de la demande (optionnel)
   * @param basePrice Prix de base initial pour les calculs de pourcentage (optionnel)
   * @returns R√©sultat de l'application de la r√®gle
   */
  apply(price: Money, context?: any, basePrice?: Money): RuleApplyResult {
    if (!this.isActive) {
      return {
        success: false,
        modified: false,
        message: "Rule is inactive",
        price: price.getAmount(),
        isApplied: false,
        impact: 0,
        newPrice: new Money(price.getAmount())
      };
    }

    const priceAmount = price.getAmount();
    let newPrice = priceAmount;
    let multiplier = 1;

    // üîÑ LOGIQUE DE MULTIPLICATION POUR CONTRAINTES LOGISTIQUES
    // ‚úÖ JUSTIFICATION: TOUTES les contraintes logistiques se multiplient par adresse (d√©part + arriv√©e)
    // Exemple: stationnement difficile au d√©part ET √† l'arriv√©e = 2x le co√ªt
    if (context && this.condition) {
      // Toutes les contraintes logistiques se multiplient par nombre d'adresses concern√©es
      const logisticsConstraints = [
        'furniture_lift_required', 'pedestrian_zone', 'narrow_inaccessible_street',
        'difficult_parking', 'complex_traffic', 'elevator_unavailable',
        'elevator_unsuitable_size', 'elevator_forbidden_moving', 'difficult_stairs',
        'narrow_corridors', 'long_carrying_distance', 'indirect_exit',
        'complex_multilevel_access', 'access_control', 'administrative_permit',
        'time_restrictions', 'fragile_floor', 'bulky_furniture',
        'furniture_disassembly', 'furniture_reassembly', 'professional_packing_departure',
        'professional_unpacking_arrival', 'packing_supplies', 'fragile_valuable_items',
        'heavy_items', 'additional_insurance', 'temporary_storage_service'
      ];

      // Si la condition correspond √† une contrainte logistique
      if (logisticsConstraints.includes(this.condition)) {
        multiplier = this.countLogisticsConstraint(context, this.condition);
        console.log(`üìç [R√àGLE-LOGISTIQUE] "${this.name}" appliqu√©e ${multiplier}x (${multiplier === 2 ? 'd√©part+arriv√©e' : multiplier === 1 ? 'une adresse' : 'aucune adresse'})`);
        
        // Si la contrainte n'est pr√©sente nulle part, ne pas appliquer la r√®gle
        if (multiplier === 0) {
          return {
            success: true,
            modified: false,
            price: priceAmount,
            isApplied: false,
            impact: 0,
            newPrice: new Money(priceAmount)
          };
        }
      }
    }

    if (this.isPercentage()) {
      // üîß CORRECTION: Pour les pourcentages, utiliser le prix de base initial si fourni
      const basePriceAmount = basePrice ? basePrice.getAmount() : priceAmount;
      const percentageValue = this.value * multiplier;
      const percentageImpact = Math.round(basePriceAmount * percentageValue / 100);
      newPrice = priceAmount + percentageImpact;
    } else {
      // Si la valeur est un montant fixe, multiplier par le nombre d'occurrences
      newPrice = Math.round(priceAmount + (this.value * multiplier));
    }
    
    const impact = newPrice - priceAmount;
    
    return {
      success: true,
      modified: impact !== 0,
      price: newPrice,
      isApplied: impact !== 0,
      impact: impact,
      newPrice: new Money(newPrice)
    };
  }

  /**
   * D√©termine si la valeur de la r√®gle est un pourcentage
   */
  isPercentage(): boolean {
    // Utiliser le champ percentBased si disponible, sinon utiliser l'ancienne logique comme fallback
    if (this.percentBased !== undefined) {
      return this.percentBased;
    }
    // Fallback vers l'ancienne logique
    return this.value > -1 && this.value < 1;
  }

  /**
   * D√©termine si c'est une remise ou une majoration
   */
  isDiscount(): boolean {
    return this.value < 0;
  }

  /**
   * V√©rifie si une contrainte logistique sp√©cifique est pr√©sente dans le contexte
   * @param context Contexte contenant les contraintes logistiques
   * @param constraint Nom de la contrainte √† v√©rifier
   * @returns True si la contrainte est pr√©sente
   */
  private hasLogisticsConstraint(context: any, constraint: string): boolean {
    const pickupConstraints = context.pickupLogisticsConstraints || [];
    const deliveryConstraints = context.deliveryLogisticsConstraints || [];
    
    return pickupConstraints.includes(constraint) || deliveryConstraints.includes(constraint);
  }

  /**
   * Compte combien de fois une contrainte logistique est pr√©sente (pickup + delivery)
   * @param context Contexte contenant les contraintes logistiques
   * @param constraint Nom de la contrainte √† compter
   * @returns Nombre d'occurrences (0, 1 ou 2)
   */
  private countLogisticsConstraint(context: any, constraint: string): number {
    const pickupConstraints = context.pickupLogisticsConstraints || [];
    const deliveryConstraints = context.deliveryLogisticsConstraints || [];
    
    let count = 0;
    if (pickupConstraints.includes(constraint)) count++;
    if (deliveryConstraints.includes(constraint)) count++;
    
    return count;
  }

  /**
   * Analyse si le monte-meuble est requis et quelles contraintes sont consomm√©es
   * @param context Contexte contenant toutes les donn√©es
   * @returns Analyse du monte-meuble requis et contraintes consomm√©es
   */
  private analyzeFurnitureLiftRequirement(context: any): { required: boolean; consumedConstraints: Set<string> } {
    const consumedConstraints = new Set<string>();
    let required = false;
    
    // R√©cup√©rer les donn√©es d'√©tage et d'ascenseur
    const pickupFloor = parseInt(context.pickupFloor || '0');
    const deliveryFloor = parseInt(context.deliveryFloor || '0');
    const pickupElevator = context.pickupElevator;
    const deliveryElevator = context.deliveryElevator;
    const volume = parseFloat(context.volume || '0');
    
    // Contraintes qui peuvent d√©clencher le monte-meuble
    const triggerConstraints = [
      'elevator_unavailable',
      'elevator_unsuitable_size', 
      'elevator_forbidden_moving',
      'difficult_stairs',
      'narrow_corridors',
      'indirect_exit',
      'complex_multilevel_access',
      'bulky_furniture'
    ];
    
    // V√©rifier si le monte-meuble est explicitement requis
    if (this.hasLogisticsConstraint(context, 'furniture_lift_required')) {
      required = true;
      consumedConstraints.add('furniture_lift_required');
    }
    
    // Logique d'activation automatique du monte-meuble
    const hasNoElevator = !pickupElevator || pickupElevator === 'no' || !deliveryElevator || deliveryElevator === 'no';
    const hasSmallElevator = pickupElevator === 'small' || deliveryElevator === 'small';
    const hasElevatorProblems = this.hasLogisticsConstraint(context, 'elevator_unavailable') ||
                               this.hasLogisticsConstraint(context, 'elevator_unsuitable_size') ||
                               this.hasLogisticsConstraint(context, 'elevator_forbidden_moving');
    
    const maxFloor = Math.max(pickupFloor, deliveryFloor);
    
    // CAS 1: √âtage √©lev√© (> 3) sans ascenseur fonctionnel
    if (maxFloor > 3 && (hasNoElevator || hasElevatorProblems)) {
      required = true;
      if (hasElevatorProblems) {
        if (this.hasLogisticsConstraint(context, 'elevator_unavailable')) consumedConstraints.add('elevator_unavailable');
        if (this.hasLogisticsConstraint(context, 'elevator_unsuitable_size')) consumedConstraints.add('elevator_unsuitable_size');
        if (this.hasLogisticsConstraint(context, 'elevator_forbidden_moving')) consumedConstraints.add('elevator_forbidden_moving');
      }
    }
    
    // CAS 2: Contraintes d'acc√®s difficile + objets lourds/encombrants
    const hasAccessConstraints = this.hasLogisticsConstraint(context, 'difficult_stairs') ||
                                this.hasLogisticsConstraint(context, 'narrow_corridors') ||
                                this.hasLogisticsConstraint(context, 'indirect_exit') ||
                                this.hasLogisticsConstraint(context, 'complex_multilevel_access');
    
    const hasHeavyItems = this.hasLogisticsConstraint(context, 'bulky_furniture');
    
    if (maxFloor >= 1 && hasAccessConstraints && hasHeavyItems) {
      required = true;
      
      // Marquer les contraintes comme consomm√©es
      if (this.hasLogisticsConstraint(context, 'difficult_stairs')) consumedConstraints.add('difficult_stairs');
      if (this.hasLogisticsConstraint(context, 'narrow_corridors')) consumedConstraints.add('narrow_corridors');
      if (this.hasLogisticsConstraint(context, 'indirect_exit')) consumedConstraints.add('indirect_exit');
      if (this.hasLogisticsConstraint(context, 'complex_multilevel_access')) consumedConstraints.add('complex_multilevel_access');
      if (this.hasLogisticsConstraint(context, 'bulky_furniture')) consumedConstraints.add('bulky_furniture');
    }
    
    // CAS 3: Ascenseur small + contraintes + objets lourds
    if (hasSmallElevator && hasAccessConstraints && hasHeavyItems && maxFloor >= 1) {
      required = true;
      
      // Marquer les contraintes comme consomm√©es (m√™me logique que CAS 2)
      if (this.hasLogisticsConstraint(context, 'difficult_stairs')) consumedConstraints.add('difficult_stairs');
      if (this.hasLogisticsConstraint(context, 'narrow_corridors')) consumedConstraints.add('narrow_corridors');
      if (this.hasLogisticsConstraint(context, 'indirect_exit')) consumedConstraints.add('indirect_exit');
      if (this.hasLogisticsConstraint(context, 'complex_multilevel_access')) consumedConstraints.add('complex_multilevel_access');
      if (this.hasLogisticsConstraint(context, 'bulky_furniture')) consumedConstraints.add('bulky_furniture');
    }
    
    if (required && consumedConstraints.size > 0) {
      // ‚ú® OPTIMISATION: Ce log est maintenant g√©r√© de fa√ßon centralis√©e dans RuleEngine
      // console.log(`üèóÔ∏è Monte-meuble requis - Contraintes consomm√©es:`, Array.from(consumedConstraints));
    }
    
    return { required, consumedConstraints };
  }

  /**
   * V√©rifie si cette r√®gle doit √™tre ignor√©e car sa contrainte est consomm√©e par le monte-meuble
   * @param evalContext Contexte d'√©valuation enrichi
   * @returns True si la r√®gle doit √™tre ignor√©e
   */
  private isConstraintConsumedByFurnitureLift(evalContext: any): boolean {
    // Si le monte-meuble n'est pas requis, aucune contrainte n'est consomm√©e
    if (!evalContext.monte_meuble_requis) {
      return false;
    }
    
    // Si cette r√®gle est la r√®gle du monte-meuble elle-m√™me, ne pas l'ignorer
    if (this.condition === 'furniture_lift_required' || this.name === 'Monte-meuble') {
      return false;
    }
    
    // V√©rifier si la condition de cette r√®gle correspond √† une contrainte consomm√©e
    const consumedConstraints = evalContext.consumedConstraints || new Set();
    
    // Si la condition de la r√®gle est directement dans les contraintes consomm√©es
    if (consumedConstraints.has(this.condition)) {
      return true;
    }
    
    // Cas sp√©ciaux pour les r√®gles qui v√©rifient des variables bool√©ennes
    const constraintMappings: Record<string, string> = {
      'difficult_stairs': 'difficult_stairs',
      'narrow_corridors': 'narrow_corridors', 
      'indirect_exit': 'indirect_exit',
      'complex_multilevel_access': 'complex_multilevel_access',
      'bulky_furniture': 'bulky_furniture',
      'elevator_unavailable': 'elevator_unavailable',
      'elevator_unsuitable_size': 'elevator_unsuitable_size',
      'elevator_forbidden_moving': 'elevator_forbidden_moving'
    };
    
    // V√©rifier si la condition correspond √† une contrainte mapp√©e qui est consomm√©e
    const mappedConstraint = constraintMappings[this.condition];
    if (mappedConstraint && consumedConstraints.has(mappedConstraint)) {
      return true;
    }
    
    return false;
  }

  /**
   * ‚úÖ NOUVELLE M√âTHODE: √âvalue une condition JSON intelligemment
   * @param conditionObj Objet JSON condition
   * @param context Contexte d'√©valuation
   * @returns True si la condition est remplie
   */
  private evaluateJsonCondition(conditionObj: any, context: any): boolean {
    // ‚úÖ CORRECTION IMPORTANTE: Mapper la condition JSON compl√®te vers LE BON nom de contrainte
    // Utiliser toutes les propri√©t√©s de la condition, pas juste le type

    // Mapper les conditions JSON compl√®tes vers les noms de contraintes
    const constraintName = this.mapJsonConditionToConstraintName(conditionObj);

    if (!constraintName) {
      console.warn(`‚ö†Ô∏è Impossible de mapper la condition JSON pour r√®gle "${this.name}":`, conditionObj);
      return false;
    }

    // ‚úÖ AM√âLIORATION: V√©rifier si la contrainte est pr√©sente dans le contexte
    // Support de plusieurs formats:
    // 1. Format complet: pickupLogisticsConstraints / deliveryLogisticsConstraints
    // 2. Format simple: constraints (pour les tests et certains formulaires)
    // 3. Format services: services (pour les services additionnels)

    const pickupConstraints = context.pickupLogisticsConstraints || [];
    const deliveryConstraints = context.deliveryLogisticsConstraints || [];
    const simpleConstraints = context.constraints || [];
    const simpleServices = context.services || [];

    // Combiner toutes les sources de contraintes
    const allConstraints = [
      ...pickupConstraints,
      ...deliveryConstraints,
      ...simpleConstraints,
      ...simpleServices
    ];

    const hasConstraint = allConstraints.includes(constraintName);

    return hasConstraint;
  }

  /**
   * Mappe une condition JSON compl√®te vers le nom de contrainte correspondant
   * @param conditionObj Objet JSON condition
   * @returns Le nom de la contrainte ou null si non trouv√©
   */
  private mapJsonConditionToConstraintName(conditionObj: any): string | null {
    const type = conditionObj.type;

    // üîç Mapping pr√©cis bas√© sur toutes les propri√©t√©s de la condition

    // Vehicle Access
    if (type === 'vehicle_access') {
      if (conditionObj.zone === 'pedestrian') return 'pedestrian_zone';
      if (conditionObj.road === 'narrow') return 'narrow_inaccessible_street';
      if (conditionObj.parking === 'difficult') return 'difficult_parking';
      if (conditionObj.parking === 'limited') return 'limited_parking';
      if (conditionObj.traffic === 'complex') return 'complex_traffic';
    }

    // Building
    if (type === 'building') {
      if (conditionObj.elevator === 'unavailable') return 'elevator_unavailable';
      if (conditionObj.elevator === 'small') return 'elevator_unsuitable_size';
      if (conditionObj.elevator === 'forbidden') return 'elevator_forbidden_moving';
      if (conditionObj.stairs === 'difficult') return 'difficult_stairs';
      if (conditionObj.corridors === 'narrow') return 'narrow_corridors';
    }

    // Distance
    if (type === 'distance') {
      if (conditionObj.carrying === 'long') return 'long_carrying_distance';
      if (conditionObj.access === 'indirect') return 'indirect_exit';
      if (conditionObj.access === 'multilevel') return 'complex_multilevel_access';
    }

    // Security
    if (type === 'security') {
      if (conditionObj.access === 'strict') return 'access_control';
      if (conditionObj.permit === 'required') return 'administrative_permit';
      if (conditionObj.time === 'restricted') return 'time_restrictions';
      if (conditionObj.floor === 'fragile') return 'fragile_floor';
    }

    // Equipment
    if (type === 'equipment') {
      if (conditionObj.lift === 'required') return 'furniture_lift_required';
    }

    // Service - Handling
    if (type === 'service') {
      if (conditionObj.handling === 'bulky') return 'bulky_furniture';
      if (conditionObj.handling === 'disassembly') return 'furniture_disassembly';
      if (conditionObj.handling === 'reassembly') return 'furniture_reassembly';
      if (conditionObj.handling === 'piano') return 'transport_piano';

      // Service - Packing
      if (conditionObj.packing === 'departure') return 'professional_packing_departure';
      if (conditionObj.packing === 'arrival') return 'professional_unpacking_arrival';
      if (conditionObj.packing === 'supplies') return 'packing_supplies';
      if (conditionObj.packing === 'artwork') return 'artwork_packing';

      // Service - Protection
      if (conditionObj.protection === 'fragile') return 'fragile_valuable_items';
      if (conditionObj.protection === 'heavy') return 'heavy_items';
      if (conditionObj.protection === 'inventory') return 'inventory_with_photos';

      // Service - Annexe
      if (conditionObj.annexe === 'storage') return 'temporary_storage_service';
      if (conditionObj.annexe === 'cleaning') return 'post_move_cleaning';
      if (conditionObj.annexe === 'admin') return 'administrative_management';
      if (conditionObj.annexe === 'pets') return 'pet_transport';

      // ‚úÖ CLEANING - Services sp√©cialis√©s (mapping des noms fran√ßais)
      if (conditionObj.specialized === 'deep') return 'Grand nettoyage de printemps';
      if (conditionObj.specialized === 'carpet') return 'Nettoyage tapis et moquettes';
      if (conditionObj.specialized === 'windows') return 'Nettoyage vitres complet';
      if (conditionObj.specialized === 'appliances') return 'Nettoyage √©lectrom√©nager';

      // CLEANING - D√©sinfection
      if (conditionObj.disinfection === 'complete') return 'D√©sinfection compl√®te';
      if (conditionObj.disinfection === 'covid') return 'Protocole sanitaire renforc√©';
      if (conditionObj.disinfection === 'allergen') return 'Traitement anti-allerg√®nes';

      // CLEANING - Maintenance
      if (conditionObj.maintenance === 'furniture') return 'Entretien mobilier';
      if (conditionObj.maintenance === 'silver') return 'Nettoyage argenterie';
      if (conditionObj.maintenance === 'organization') return 'Rangement et organisation';

      // CLEANING - Logistique
      if (conditionObj.logistics === 'supply') return 'R√©approvisionnement produits';
      if (conditionObj.logistics === 'waste') return '√âvacuation d√©chets';
      if (conditionObj.logistics === 'keys') return 'Gestion trousseau de cl√©s';
    }

    // ‚úÖ CLEANING - Contraintes d'acc√®s
    if (type === 'access') {
      if (conditionObj.parking === 'limited') return 'Stationnement limit√© ou payant';
      if (conditionObj.elevator === 'none') return 'Absence d\'ascenseur';
      if (conditionObj.building === 'difficult') return 'Acc√®s difficile au b√¢timent';
      if (conditionObj.security === 'strict') return 'Contr√¥le de s√©curit√© strict';
    }

    // ‚úÖ CLEANING - Contraintes de travail
    if (type === 'work') {
      if (conditionObj.pets === 'present') return 'Pr√©sence d\'animaux';
      if (conditionObj.children === 'present') return 'Pr√©sence d\'enfants';
      if (conditionObj.allergies === 'present') return 'Allergies signal√©es';
      if (conditionObj.items === 'fragile') return 'Objets fragiles/pr√©cieux';
      if (conditionObj.furniture === 'heavy') return 'Meubles lourds √† d√©placer';
    }

    // ‚úÖ CLEANING - Contraintes horaires
    if (type === 'schedule') {
      if (conditionObj.window === 'specific') return 'Cr√©neau horaire sp√©cifique';
      if (conditionObj.time === 'early') return 'Intervention matinale';
      if (conditionObj.time === 'evening') return 'Service en soir√©e';
      if (conditionObj.day === 'weekend') return 'Service weekend';
      if (conditionObj.urgency === 'emergency') return 'Service d\'urgence';
    }

    // ‚úÖ CLEANING - Contraintes de lieu
    if (type === 'location') {
      if (conditionObj.dirt === 'heavy') return 'Salet√© importante/tenace';
      if (conditionObj.work === 'construction') return 'Post-construction/travaux';
      if (conditionObj.damage === 'water') return 'D√©g√¢ts des eaux r√©cents';
      if (conditionObj.mold === 'present') return 'Pr√©sence de moisissure';
      if (conditionObj.space === 'limited') return 'Espace tr√®s restreint';
      if (conditionObj.hoarding === 'present') return 'Situation d\'accumulation';
    }

    // ‚úÖ CLEANING - Contraintes utilitaires
    if (type === 'utilities') {
      if (conditionObj.water === 'none') return 'Pas d\'acc√®s √† l\'eau';
      if (conditionObj.power === 'none') return 'Pas d\'√©lectricit√©';
      if (conditionObj.products === 'special') return 'Produits sp√©cifiques requis';
      if (conditionObj.equipment === 'industrial') return '√âquipement industriel requis';
      if (conditionObj.height === 'required') return 'Travail en hauteur';
    }

    return null;
  }

  /**
   * Compare deux r√®gles pour v√©rifier si elles sont identiques
   * @param other Autre r√®gle √† comparer
   * @returns True si les r√®gles sont identiques
   */
  equals(other: Rule): boolean {
    if (!other) return false;

    return (
      this.id === other.id &&
      this.name === other.name &&
      this.serviceType === other.serviceType &&
      this.value === other.value &&
      this.condition === other.condition &&
      this.isActive === other.isActive
    );
  }
}