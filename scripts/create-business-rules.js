 const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

// Donn√©es des contraintes et services avec valeurs r√©alistes
const constraintsData = [
  // üöõ Acc√®s v√©hicule
  { id: 'pedestrian_zone', name: 'Zone pi√©tonne avec restrictions', category: 'vehicle', value: 75, description: 'N√©cessite autorisation municipale + portage plus long', percentBased: false },
  { id: 'narrow_inaccessible_street', name: 'Rue √©troite ou inaccessible au camion', category: 'vehicle', value: 120, description: 'Le camion doit stationner plus loin, allongeant la manutention', percentBased: false },
  { id: 'difficult_parking', name: 'Stationnement difficile ou payant', category: 'vehicle', value: 40, description: 'Le temps de recherche et les frais de stationnement doivent √™tre compens√©s', percentBased: false },
  { id: 'complex_traffic', name: 'Sens unique ou circulation complexe', category: 'vehicle', value: 30, description: 'Itin√©raire rallong√© ou difficile √† naviguer, surtout en ville', percentBased: false },
  
  // üè¢ Contraintes b√¢timent
  { id: 'elevator_unavailable', name: 'Ascenseur en panne ou hors service', category: 'building', value: 180, description: 'Oblige √† tout porter manuellement sur plusieurs √©tages', percentBased: false },
  { id: 'elevator_unsuitable_size', name: 'Ascenseur trop petit pour les meubles', category: 'building', value: 120, description: 'N√©cessite d√©montage ou portage manuel partiel', percentBased: false },
  { id: 'elevator_forbidden_moving', name: 'Ascenseur interdit pour d√©m√©nagement', category: 'building', value: 150, description: 'Souvent stipul√© dans les r√®glements d\'immeuble, oblige le portage par escalier', percentBased: false },
  { id: 'difficult_stairs', name: 'Escalier √©troit, en colima√ßon ou dangereux', category: 'building', value: 200, description: 'Allonge le temps, augmente le risque de casse', percentBased: false },
  { id: 'narrow_corridors', name: 'Couloirs √©troits ou encombr√©s', category: 'building', value: 90, description: 'Oblige √† man≈ìuvrer avec pr√©caution, parfois d√©monter davantage de meubles', percentBased: false },
  
  // üìè Distance et portage
  { id: 'long_carrying_distance', name: 'Distance immeuble‚Äìcamion > 30 m', category: 'distance', value: 3.5, description: 'Temps de trajet pi√©ton suppl√©mentaire par aller-retour', percentBased: false },
  { id: 'indirect_exit', name: 'Passage par cour, jardin ou sous-sol', category: 'distance', value: 100, description: 'Itin√©raire de sortie plus long ou complexe', percentBased: false },
  { id: 'complex_multilevel_access', name: 'Acc√®s complexe multi-niveaux', category: 'distance', value: 150, description: 'Parcours avec escaliers, rampes, niveaux interm√©diaires', percentBased: false },
  
  // üõ°Ô∏è S√©curit√© et autorisations
  { id: 'access_control', name: 'Contr√¥le d\'acc√®s strict', category: 'security', value: 60, description: 'Badge, gardiennage ou enregistrement ralentissent l\'intervention', percentBased: false },
  { id: 'administrative_permit', name: 'Autorisation administrative obligatoire', category: 'security', value: 80, description: 'Permis de stationnement ou occupation de voirie √† payer √† la mairie', percentBased: false },
  { id: 'time_restrictions', name: 'Restrictions horaires strictes', category: 'security', value: 70, description: 'Plages horaires r√©duites, organisation logistique plus contraignante', percentBased: false },
  { id: 'fragile_floor', name: 'Sol fragile ou d√©licat', category: 'security', value: 55, description: 'Protection suppl√©mentaire (planches, tapis, film), rallonge l\'intervention', percentBased: false },
];

// Services suppl√©mentaires avec valeurs r√©alistes
const servicesData = [
  // üîß Services de manutention
  { id: 'bulky_furniture', name: 'Meubles encombrants ou non d√©montables', category: 'handling', value: 180, description: 'Peut n√©cessiter main d\'≈ìuvre renforc√©e, monte-meuble, ou d√©montage complexe', percentBased: false },
  { id: 'furniture_disassembly', name: 'D√©montage de meubles au d√©part', category: 'handling', value: 30, description: 'Factur√© par meuble ou par heure, selon complexit√©', percentBased: false },
  { id: 'furniture_reassembly', name: 'Remontage de meubles √† l\'arriv√©e', category: 'handling', value: 30, description: 'Inclus dans certains packs, sinon factur√© √† la prestation', percentBased: false },
  
  // üì¶ Services d'emballage
  { id: 'professional_packing_departure', name: 'Emballage professionnel au d√©part', category: 'packing', value: 200, description: 'Inclut le mat√©riel et la main d\'≈ìuvre qualifi√©e', percentBased: false },
  { id: 'professional_unpacking_arrival', name: 'D√©ballage professionnel √† l\'arriv√©e', category: 'packing', value: 150, description: 'Souvent combin√© avec nettoyage ou r√©installation', percentBased: false },
  { id: 'packing_supplies', name: 'Fournitures d\'emballage compl√®tes', category: 'packing', value: 100, description: 'Cartons, papier bulle, scotch, housses, film', percentBased: false },
  
  // üõ°Ô∏è Services de protection
  { id: 'fragile_valuable_items', name: 'Objets fragiles ou de grande valeur', category: 'protection', value: 0.5, description: 'Pour assurer ou emballer des ≈ìuvres, instruments, √©crans, etc.', percentBased: true },
  { id: 'heavy_items', name: 'Objets tr√®s lourds (piano, coffre-fort...)', category: 'protection', value: 400, description: 'N√©cessite manutention sp√©cialis√©e (sangles, √©quipe renforc√©e, monte-charge)', percentBased: false },
  { id: 'additional_insurance', name: 'Assurance compl√©mentaire renforc√©e', category: 'protection', value: 0.4, description: 'Couvre la casse ou perte de biens de valeur selon montant d√©clar√©', percentBased: true },
  
  // üè™ Services annexes
  { id: 'temporary_storage_service', name: 'Stockage temporaire s√©curis√©', category: 'annexe', value: 60, description: 'Prix moyen d\'un garde-meuble s√©curis√© dans un d√©m√©nagement avec d√©calage', percentBased: false },
];

async function createBusinessRules() {
  try {
    console.log('üèóÔ∏è CR√âATION DES R√àGLES M√âTIER POUR SUPABASE');
    console.log('=' .repeat(60));
    
    let createdCount = 0;
    let skippedCount = 0;
    
    // Cr√©er les r√®gles pour les contraintes
    console.log('\nüìã CR√âATION DES R√àGLES POUR LES CONTRAINTES LOGISTIQUES');
    for (const constraint of constraintsData) {
      // V√©rifier si la r√®gle existe d√©j√†
      const existingRule = await prisma.rule.findFirst({
        where: { 
          name: constraint.name,
          serviceType: 'MOVING'
        }
      });
      
      if (existingRule) {
        console.log(`‚è≠Ô∏è  R√®gle "${constraint.name}" existe d√©j√† - mise √† jour`);
        // Mettre √† jour la r√®gle existante avec les nouvelles valeurs
        await prisma.rule.update({
          where: { id: existingRule.id },
          data: {
            value: constraint.value,
            description: constraint.description,
            percentBased: constraint.percentBased !== false
          }
        });
        console.log(`‚úÖ Contrainte mise √† jour: ${constraint.name} (${constraint.value}‚Ç¨)`);
        skippedCount++;
        continue;
      }
      
      const rule = await prisma.rule.create({
        data: {
          name: constraint.name,
          description: constraint.description,
          value: constraint.value,
          percentBased: constraint.percentBased !== false, // Par d√©faut true sauf si explicitement false
          isActive: true,
          serviceType: 'MOVING',
          category: 'SURCHARGE', // Les contraintes sont des surcharges
          condition: constraint.id // Variable bool√©enne cr√©√©e dans Rule.isApplicable()
        }
      });
      
      console.log(`‚úÖ Contrainte cr√©√©e: ${rule.name} (${rule.value}${rule.percentBased ? '%' : '‚Ç¨'})`);
      createdCount++;
    }
    
    // Cr√©er les r√®gles pour les services suppl√©mentaires
    console.log('\nüîß CR√âATION DES R√àGLES POUR LES SERVICES SUPPL√âMENTAIRES');
    for (const service of servicesData) {
      // V√©rifier si la r√®gle existe d√©j√†
      const existingRule = await prisma.rule.findFirst({
        where: { 
          name: service.name,
          serviceType: 'MOVING'
        }
      });
      
      if (existingRule) {
        console.log(`‚è≠Ô∏è  R√®gle "${service.name}" existe d√©j√† - mise √† jour`);
        // Mettre √† jour la r√®gle existante avec les nouvelles valeurs
        await prisma.rule.update({
          where: { id: existingRule.id },
          data: {
            value: service.value,
            description: service.description,
            percentBased: service.percentBased === true
          }
        });
        console.log(`‚úÖ Service mis √† jour: ${service.name} (${service.value}${service.percentBased === true ? '%' : '‚Ç¨'})`);
        skippedCount++;
        continue;
      }
      
      const rule = await prisma.rule.create({
        data: {
          name: service.name,
          description: service.description,
          value: service.value,
          percentBased: service.percentBased === true, // Par d√©faut false sauf si explicitement true
          isActive: true,
          serviceType: 'MOVING',
          category: 'SURCHARGE', // Les services sont des surcharges
          condition: service.id // Variable bool√©enne cr√©√©e dans Rule.isApplicable()
        }
      });
      
      console.log(`‚úÖ Service cr√©√©: ${rule.name} (${rule.value}${rule.percentBased ? '%' : '‚Ç¨'})`);
      createdCount++;
    }
    
    // Cr√©er la r√®gle sp√©ciale pour le monte-meuble (si elle n'existe pas d√©j√†)
    console.log('\nüèóÔ∏è V√âRIFICATION DE LA R√àGLE MONTE-MEUBLE');
    const furnitureLiftRule = await prisma.rule.findFirst({
      where: { 
        name: 'Monte-meuble',
        serviceType: 'MOVING'
      }
    });
    
    if (!furnitureLiftRule) {
      const rule = await prisma.rule.create({
        data: {
          name: 'Monte-meuble',
          description: 'Indispensable si escalier ou ascenseur inutilisables ou objets tr√®s encombrants',
          value: 250,
          percentBased: false,
          isActive: true,
          serviceType: 'MOVING',
          category: 'SURCHARGE',
          condition: 'furniture_lift_required'
        }
      });
      
      console.log(`‚úÖ R√®gle monte-meuble cr√©√©e: ${rule.name} (${rule.value}‚Ç¨)`);
      createdCount++;
    } else {
      console.log(`‚è≠Ô∏è  R√®gle monte-meuble existe d√©j√† - mise √† jour de la valeur`);
      // Mettre √† jour la r√®gle existante avec les nouvelles valeurs
      await prisma.rule.update({
        where: { id: furnitureLiftRule.id },
        data: {
          value: 250,
          description: 'Indispensable si escalier ou ascenseur inutilisables ou objets tr√®s encombrants'
        }
      });
      console.log(`‚úÖ R√®gle monte-meuble mise √† jour: ${furnitureLiftRule.name} (250‚Ç¨)`);
      skippedCount++;
    }
    
    // R√©sum√© final
    console.log('\n' + '=' .repeat(60));
    console.log('üìä R√âSUM√â DE LA CR√âATION DES R√àGLES');
    console.log(`‚úÖ R√®gles cr√©√©es: ${createdCount}`);
    console.log(`‚è≠Ô∏è  R√®gles ignor√©es (d√©j√† existantes): ${skippedCount}`);
    console.log(`üìã Total de contraintes: ${constraintsData.length}`);
    console.log(`üîß Total de services: ${servicesData.length}`);
    console.log(`üèóÔ∏è R√®gle monte-meuble: 1`);
    console.log(`üéØ Total attendu: ${constraintsData.length + servicesData.length + 1}`);
    
    // V√©rification finale
    console.log('\nüîç V√âRIFICATION FINALE');
    const totalRules = await prisma.rule.count({
      where: { serviceType: 'MOVING' }
    });
    console.log(`üìä Total des r√®gles MOVING en base: ${totalRules}`);
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la cr√©ation des r√®gles:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// Fonction utilitaire pour afficher la structure des r√®gles
async function displayRulesStructure() {
  try {
    console.log('\nüìã STRUCTURE DES R√àGLES G√âN√âR√âES');
    console.log('=' .repeat(80));
    
    const rules = await prisma.rule.findMany({
      where: { serviceType: 'MOVING' },
      orderBy: [
        { category: 'asc' },
        { name: 'asc' }
      ]
    });
    
    const groupedRules = rules.reduce((groups, rule) => {
      if (!groups[rule.category]) {
        groups[rule.category] = [];
      }
      groups[rule.category].push(rule);
      return groups;
    }, {});
    
    Object.entries(groupedRules).forEach(([category, categoryRules]) => {
      console.log(`\nüìÇ ${category} (${categoryRules.length} r√®gles)`);
      categoryRules.forEach(rule => {
        console.log(`  ‚Ä¢ ${rule.name}: ${rule.value}${rule.percentBased ? '%' : '‚Ç¨'} (${rule.condition})`);
      });
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'affichage:', error);
  }
}

// Ex√©cution du script
if (require.main === module) {
  createBusinessRules()
    .then(() => displayRulesStructure())
    .then(() => {
      console.log('\nüéâ SCRIPT TERMIN√â AVEC SUCC√àS');
      process.exit(0);
    })
    .catch((error) => {
      console.error('üí• ERREUR FATALE:', error);
      process.exit(1);
    });
}

module.exports = { createBusinessRules, displayRulesStructure }; 